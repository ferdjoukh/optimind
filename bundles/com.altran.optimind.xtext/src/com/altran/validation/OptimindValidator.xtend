/*
 * generated by Xtext 2.15.0
 */
package com.altran.validation

import com.altran.optimind.model.workflow.AbstractTask
import com.altran.optimind.model.workflow.BaseTask
import com.altran.optimind.model.workflow.LibraryTask
import com.altran.optimind.model.workflow.NamedElement
import com.altran.optimind.model.workflow.Workflow
import com.altran.optimind.model.workflow.WorkflowPackage
import java.util.stream.Collectors
import org.eclipse.xtext.validation.Check
import com.altran.optimind.model.workflow.TypedElement
import com.altran.optimind.model.workflow.LibraryFunction
import com.altran.optimind.model.workflow.SimpleTask
import com.altran.optimind.model.workflow.CustomTask
import com.altran.optimind.model.workflow.TaskInput
import com.altran.optimind.model.workflow.Setter
import com.altran.optimind.model.workflow.Connection
import java.util.ArrayList
import org.eclipse.emf.common.util.EList
import com.altran.optimind.model.workflow.Language

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class OptimindValidator extends AbstractOptimindValidator {
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					OptimindPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	@Check
	def checkWorkflow(Workflow workflow) {
		
		if ( workflow.baseTask === null ){
			error("Workflow needs one and only one BaseTask", WorkflowPackage.Literals.WORKFLOW__BASE_TASK)
		}
		
		if ( workflow.language !== Language.PYTHON) {
			warning("workflow language unspecified", WorkflowPackage.Literals.WORKFLOW__LANGUAGE)
		}
		
		
		var functions = workflow.functions
		var names = functions.stream().map[name].collect(Collectors.toSet)
		
		if ( functions.size != names.size ){
			error("For a Workflow, the names of LibraryFunctions must be unique", WorkflowPackage.Literals.WORKFLOW__FUNCTIONS)
		}	
	}
	
	@Check
	def checkNamedElement(NamedElement named){
		if(named.name === null){
			error("This Element must have a Name", WorkflowPackage.Literals.NAMED_ELEMENT__NAME)
		}
	}
	
	@Check
	def checkTypedElement(TypedElement typed){
		if(typed.typeAsString === null){
			error("This Element must have a Type", WorkflowPackage.Literals.TYPED_ELEMENT__TYPE_AS_STRING)
		}
	}
	
	@Check
	def checkAbstractTask(AbstractTask atask){
		
		if (atask.inputs.size !=  atask.inputs.stream().map[name].collect(Collectors.toSet).size){
			error("For a Task, cannot use the same Input name twice", WorkflowPackage.Literals.ABSTRACT_TASK__INPUTS)
		}
		
		if (atask.outputs.size !=  atask.outputs.stream().map[name].collect(Collectors.toSet).size){
			error("For a Task, cannot use the same Output name twice", WorkflowPackage.Literals.ABSTRACT_TASK__OUTPUTS)
		}
	}
	
	@Check
	def checkBaseTask(BaseTask baseTask){
		if (baseTask.inputs.size > 0){
			error("BaseTask does not admit inputs", WorkflowPackage.Literals.ABSTRACT_TASK__INPUTS)	
		}
		
		if (baseTask.outputs.size > 0){
			error("BaseTask does not admit outputs", WorkflowPackage.Literals.ABSTRACT_TASK__OUTPUTS)	
		}
		
		if (baseTask.children.size != baseTask.children.stream().map[name].collect(Collectors.toSet).size){
			error("For a BaseTask, the names of children must be unique", WorkflowPackage.Literals.BASE_TASK__CHILDREN)
		}
	}
	
	@Check
	def checkSimpleTask(SimpleTask simpleTask){
		
		
	}
	
	@Check
	def checkCustomTask(CustomTask customTask){
		if(customTask.runner === null){
			error("A CustomTask must have a Runner",WorkflowPackage.Literals.CUSTOM_TASK__RUNNER);
		}
	}
	
	@Check
	def checkLibraryTask(LibraryTask t){
		
		if(t.libraryfunction === null){
			error("A LibraryTask must have a reference on a LibraryFunction  ",WorkflowPackage.Literals.LIBRARY_TASK__LIBRARYFUNCTION);
		}
		
		var taskInput = t.inputs.stream().map[name].collect(Collectors.toList)
		var functionInput = t.libraryfunction.inputs.stream().map[name].collect(Collectors.toList)
		
		if( !( taskInput.containsAll(functionInput)  && functionInput.containsAll(taskInput) ) ){
			error("The Input name of a LibraryTask must be equal the Input name of referenced LibraryFunction", WorkflowPackage.Literals.ABSTRACT_TASK__INPUTS)
		}
		
		var taskOutput = t.outputs.stream().map[name].collect(Collectors.toList)
		var functionOutput = t.libraryfunction.outputs.stream().map[name].collect(Collectors.toList)  
		
		if( !( taskOutput.containsAll(functionOutput)  && functionOutput.containsAll(taskOutput)) ){
			error("The Output name of a LibraryTask must be equal the Output name of referenced LibraryFunction", WorkflowPackage.Literals.ABSTRACT_TASK__OUTPUTS)
		}
		
		
		var taskInputs = t.inputs
		var taskInputTypes = getTaskInputType(taskInputs)
		//println(taskInputTypes)
		var functionInputType = t.libraryfunction.inputs.stream().map[typeAsString].collect(Collectors.toList)
		
		if( !( taskInputTypes.containsAll(functionInputType)  && functionInputType.containsAll(taskInputTypes) ) ){
			error("The Input type of a LibraryTask must be the same as the Input type of referenced LibraryFunction", WorkflowPackage.Literals.ABSTRACT_TASK__INPUTS)
		}
		
		
		
		var taskOutputType = t.outputs.stream().map[typeAsString].collect(Collectors.toList)
		var functionOutputType = t.libraryfunction.outputs.stream().map[typeAsString].collect(Collectors.toList)  
		
		if( !( taskOutputType.containsAll(functionOutputType)  && functionOutputType.containsAll(taskOutputType)) ){
			error("The Output type of a LibraryTask must be the same as the Output type of referenced LibraryFunction", WorkflowPackage.Literals.ABSTRACT_TASK__OUTPUTS)
		}
		
	}
	
	@Check
	def checkLibraryFunction(LibraryFunction libFunction){
		
		if (libFunction.function ===null){
			error("A LibraryFunction must refers to a Function", WorkflowPackage.Literals.LIBRARY_FUNCTION__FUNCTION)
		}
		
//		if (!(libFunction.inputs.size >0)){
//			error("A LibraryFunction must have at least one input", WorkflowPackage.Literals.LIBRARY_FUNCTION__INPUTS)
//		}
//		
//		if (!(libFunction.outputs.size >0)){
//			error("A LibraryFunction must have at least one output", WorkflowPackage.Literals.LIBRARY_FUNCTION__OUTPUTS)
//		}
		
		if (libFunction.inputs.size !=  libFunction.inputs.stream().map[name].collect(Collectors.toSet).size){
			error("For a LibraryFunction, cannot use the same Input name twice", WorkflowPackage.Literals.LIBRARY_FUNCTION__INPUTS)
		}
		
		if (libFunction.outputs.size !=  libFunction.outputs.stream().map[name].collect(Collectors.toSet).size){
			error("For a LibraryFunction, cannot use the same output name twice", WorkflowPackage.Literals.LIBRARY_FUNCTION__OUTPUTS)
		}
	}
	
	@Check
	def checkConnection(Connection connection){
		if (connection.taskoutput === null){
			error("A Connection must have a reference on a TaskOutput  ",WorkflowPackage.Literals.CONNECTION__TASKOUTPUT);
		}
		
	}
	
//	@Check
//	def checkInput(Input Input){
//		if(Input.valueAsString === null){
//			warning("Unspecified input value", WorkflowPackage.Literals.INPUT)
//		}
//	}
	
	
	def ArrayList<String> getTaskInputType(EList<TaskInput> taskInputs){
		
		var taskInputTypes= new ArrayList<String>()

		for (TaskInput task : taskInputs) {
			if (task instanceof Setter) {
				var mySetter = task as Setter
				taskInputTypes.add(mySetter.typeAsString)
			}

			if (task instanceof Connection) {
				var myConnection = task as Connection
				taskInputTypes.add(myConnection.taskoutput.typeAsString)
			}
		}
		return taskInputTypes
	}
	
}
