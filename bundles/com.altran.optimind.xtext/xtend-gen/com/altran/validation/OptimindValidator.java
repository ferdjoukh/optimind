/**
 * generated by Xtext 2.15.0
 */
package com.altran.validation;

import com.altran.optimind.model.workflow.AbstractTask;
import com.altran.optimind.model.workflow.BaseTask;
import com.altran.optimind.model.workflow.Connection;
import com.altran.optimind.model.workflow.CustomTask;
import com.altran.optimind.model.workflow.Input;
import com.altran.optimind.model.workflow.Language;
import com.altran.optimind.model.workflow.LibraryFunction;
import com.altran.optimind.model.workflow.LibraryTask;
import com.altran.optimind.model.workflow.NamedElement;
import com.altran.optimind.model.workflow.Output;
import com.altran.optimind.model.workflow.Setter;
import com.altran.optimind.model.workflow.SimpleTask;
import com.altran.optimind.model.workflow.TaskInput;
import com.altran.optimind.model.workflow.TaskOutput;
import com.altran.optimind.model.workflow.TypedElement;
import com.altran.optimind.model.workflow.Workflow;
import com.altran.optimind.model.workflow.WorkflowPackage;
import com.altran.validation.AbstractOptimindValidator;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class OptimindValidator extends AbstractOptimindValidator {
  @Check
  public void checkWorkflow(final Workflow workflow) {
    BaseTask _baseTask = workflow.getBaseTask();
    boolean _tripleEquals = (_baseTask == null);
    if (_tripleEquals) {
      this.error("Workflow needs one and only one BaseTask", WorkflowPackage.Literals.WORKFLOW__BASE_TASK);
    }
    Language _language = workflow.getLanguage();
    boolean _tripleNotEquals = (_language != Language.PYTHON);
    if (_tripleNotEquals) {
      this.warning("workflow language unspecified", WorkflowPackage.Literals.WORKFLOW__LANGUAGE);
    }
    EList<LibraryFunction> functions = workflow.getFunctions();
    final Function<LibraryFunction, String> _function = (LibraryFunction it) -> {
      return it.getName();
    };
    Set<String> names = functions.stream().<String>map(_function).collect(Collectors.<String>toSet());
    int _size = functions.size();
    int _size_1 = names.size();
    boolean _notEquals = (_size != _size_1);
    if (_notEquals) {
      this.error("For a Workflow, the names of LibraryFunctions must be unique", WorkflowPackage.Literals.WORKFLOW__FUNCTIONS);
    }
  }
  
  @Check
  public void checkNamedElement(final NamedElement named) {
    String _name = named.getName();
    boolean _tripleEquals = (_name == null);
    if (_tripleEquals) {
      this.error("This Element must have a Name", WorkflowPackage.Literals.NAMED_ELEMENT__NAME);
    }
  }
  
  @Check
  public void checkTypedElement(final TypedElement typed) {
    String _typeAsString = typed.getTypeAsString();
    boolean _tripleEquals = (_typeAsString == null);
    if (_tripleEquals) {
      this.error("This Element must have a Type", WorkflowPackage.Literals.TYPED_ELEMENT__TYPE_AS_STRING);
    }
  }
  
  @Check
  public void checkAbstractTask(final AbstractTask atask) {
    int _size = atask.getInputs().size();
    final Function<TaskInput, String> _function = (TaskInput it) -> {
      return it.getName();
    };
    int _size_1 = atask.getInputs().stream().<String>map(_function).collect(Collectors.<String>toSet()).size();
    boolean _notEquals = (_size != _size_1);
    if (_notEquals) {
      this.error("For a Task, cannot use the same Input name twice", WorkflowPackage.Literals.ABSTRACT_TASK__INPUTS);
    }
    int _size_2 = atask.getOutputs().size();
    final Function<TaskOutput, String> _function_1 = (TaskOutput it) -> {
      return it.getName();
    };
    int _size_3 = atask.getOutputs().stream().<String>map(_function_1).collect(Collectors.<String>toSet()).size();
    boolean _notEquals_1 = (_size_2 != _size_3);
    if (_notEquals_1) {
      this.error("For a Task, cannot use the same Output name twice", WorkflowPackage.Literals.ABSTRACT_TASK__OUTPUTS);
    }
  }
  
  @Check
  public void checkBaseTask(final BaseTask baseTask) {
    int _size = baseTask.getInputs().size();
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      this.error("BaseTask does not admit inputs", WorkflowPackage.Literals.ABSTRACT_TASK__INPUTS);
    }
    int _size_1 = baseTask.getOutputs().size();
    boolean _greaterThan_1 = (_size_1 > 0);
    if (_greaterThan_1) {
      this.error("BaseTask does not admit outputs", WorkflowPackage.Literals.ABSTRACT_TASK__OUTPUTS);
    }
    int _size_2 = baseTask.getChildren().size();
    final Function<AbstractTask, String> _function = (AbstractTask it) -> {
      return it.getName();
    };
    int _size_3 = baseTask.getChildren().stream().<String>map(_function).collect(Collectors.<String>toSet()).size();
    boolean _notEquals = (_size_2 != _size_3);
    if (_notEquals) {
      this.error("For a BaseTask, the names of children must be unique", WorkflowPackage.Literals.BASE_TASK__CHILDREN);
    }
  }
  
  @Check
  public Object checkSimpleTask(final SimpleTask simpleTask) {
    return null;
  }
  
  @Check
  public void checkCustomTask(final CustomTask customTask) {
    String _runner = customTask.getRunner();
    boolean _tripleEquals = (_runner == null);
    if (_tripleEquals) {
      this.error("A CustomTask must have a Runner", WorkflowPackage.Literals.CUSTOM_TASK__RUNNER);
    }
  }
  
  @Check
  public void checkLibraryTask(final LibraryTask t) {
    LibraryFunction _libraryfunction = t.getLibraryfunction();
    boolean _tripleEquals = (_libraryfunction == null);
    if (_tripleEquals) {
      this.error("A LibraryTask must have a reference on a LibraryFunction  ", WorkflowPackage.Literals.LIBRARY_TASK__LIBRARYFUNCTION);
    }
    final Function<TaskInput, String> _function = (TaskInput it) -> {
      return it.getName();
    };
    List<String> taskInput = t.getInputs().stream().<String>map(_function).collect(Collectors.<String>toList());
    final Function<Input, String> _function_1 = (Input it) -> {
      return it.getName();
    };
    List<String> functionInput = t.getLibraryfunction().getInputs().stream().<String>map(_function_1).collect(Collectors.<String>toList());
    boolean _not = (!(taskInput.containsAll(functionInput) && functionInput.containsAll(taskInput)));
    if (_not) {
      this.error("The Input name of a LibraryTask must be equal the Input name of referenced LibraryFunction", WorkflowPackage.Literals.ABSTRACT_TASK__INPUTS);
    }
    final Function<TaskOutput, String> _function_2 = (TaskOutput it) -> {
      return it.getName();
    };
    List<String> taskOutput = t.getOutputs().stream().<String>map(_function_2).collect(Collectors.<String>toList());
    final Function<Output, String> _function_3 = (Output it) -> {
      return it.getName();
    };
    List<String> functionOutput = t.getLibraryfunction().getOutputs().stream().<String>map(_function_3).collect(Collectors.<String>toList());
    boolean _not_1 = (!(taskOutput.containsAll(functionOutput) && functionOutput.containsAll(taskOutput)));
    if (_not_1) {
      this.error("The Output name of a LibraryTask must be equal the Output name of referenced LibraryFunction", WorkflowPackage.Literals.ABSTRACT_TASK__OUTPUTS);
    }
    EList<TaskInput> taskInputs = t.getInputs();
    ArrayList<String> taskInputTypes = this.getTaskInputType(taskInputs);
    final Function<Input, String> _function_4 = (Input it) -> {
      return it.getTypeAsString();
    };
    List<String> functionInputType = t.getLibraryfunction().getInputs().stream().<String>map(_function_4).collect(Collectors.<String>toList());
    boolean _not_2 = (!(taskInputTypes.containsAll(functionInputType) && functionInputType.containsAll(taskInputTypes)));
    if (_not_2) {
      this.error("The Input type of a LibraryTask must be the same as the Input type of referenced LibraryFunction", WorkflowPackage.Literals.ABSTRACT_TASK__INPUTS);
    }
    final Function<TaskOutput, String> _function_5 = (TaskOutput it) -> {
      return it.getTypeAsString();
    };
    List<String> taskOutputType = t.getOutputs().stream().<String>map(_function_5).collect(Collectors.<String>toList());
    final Function<Output, String> _function_6 = (Output it) -> {
      return it.getTypeAsString();
    };
    List<String> functionOutputType = t.getLibraryfunction().getOutputs().stream().<String>map(_function_6).collect(Collectors.<String>toList());
    boolean _not_3 = (!(taskOutputType.containsAll(functionOutputType) && functionOutputType.containsAll(taskOutputType)));
    if (_not_3) {
      this.error("The Output type of a LibraryTask must be the same as the Output type of referenced LibraryFunction", WorkflowPackage.Literals.ABSTRACT_TASK__OUTPUTS);
    }
  }
  
  @Check
  public void checkLibraryFunction(final LibraryFunction libFunction) {
    String _function = libFunction.getFunction();
    boolean _tripleEquals = (_function == null);
    if (_tripleEquals) {
      this.error("A LibraryFunction must refers to a Function", WorkflowPackage.Literals.LIBRARY_FUNCTION__FUNCTION);
    }
    int _size = libFunction.getInputs().size();
    final Function<Input, String> _function_1 = (Input it) -> {
      return it.getName();
    };
    int _size_1 = libFunction.getInputs().stream().<String>map(_function_1).collect(Collectors.<String>toSet()).size();
    boolean _notEquals = (_size != _size_1);
    if (_notEquals) {
      this.error("For a LibraryFunction, cannot use the same Input name twice", WorkflowPackage.Literals.LIBRARY_FUNCTION__INPUTS);
    }
    int _size_2 = libFunction.getOutputs().size();
    final Function<Output, String> _function_2 = (Output it) -> {
      return it.getName();
    };
    int _size_3 = libFunction.getOutputs().stream().<String>map(_function_2).collect(Collectors.<String>toSet()).size();
    boolean _notEquals_1 = (_size_2 != _size_3);
    if (_notEquals_1) {
      this.error("For a LibraryFunction, cannot use the same output name twice", WorkflowPackage.Literals.LIBRARY_FUNCTION__OUTPUTS);
    }
  }
  
  @Check
  public void checkConnection(final Connection connection) {
    TaskOutput _taskoutput = connection.getTaskoutput();
    boolean _tripleEquals = (_taskoutput == null);
    if (_tripleEquals) {
      this.error("A Connection must have a reference on a TaskOutput  ", WorkflowPackage.Literals.CONNECTION__TASKOUTPUT);
    }
  }
  
  public ArrayList<String> getTaskInputType(final EList<TaskInput> taskInputs) {
    ArrayList<String> taskInputTypes = new ArrayList<String>();
    for (final TaskInput task : taskInputs) {
      {
        if ((task instanceof Setter)) {
          Setter mySetter = ((Setter) task);
          taskInputTypes.add(mySetter.getTypeAsString());
        }
        if ((task instanceof Connection)) {
          Connection myConnection = ((Connection) task);
          taskInputTypes.add(myConnection.getTaskoutput().getTypeAsString());
        }
      }
    }
    return taskInputTypes;
  }
}
